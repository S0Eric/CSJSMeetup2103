# Introduction

Hello everyone, my name is Eric Schmucker.

I have a lot to cover, so I'll try and move along quickly, but please don't hesitate to stop me to ask questions or give feedback.

Solid is a client side framework where the components managed by Solid are rendered and updated completely in the browser. Having all or part of your web application rendered and managed client side lets your UI be very responsive. It also supports offline web applications that store data in local storage and synchronizes with a backend server when back online.

This approach can **also** be used to create cross-platform apps, with frameworks like Apache Cordova for mobile, and Electron for desktop, leveraging your HTML, CSS and JavaScript knowledge to create an app that runs anywhere.

====Open https://www.blazemetrics.com/====

The company I work for makes microscope-like devices that monitor chemical experiments, and production processes, continually capturing and analyzing images to report what's happening in the reaction chamber. The application is written in C++ for the core logic, with the UI implemented in an embedded Chromium window.

Our UI shows images, charts, and tables of data, all dynamically generated by JavaScript. There's a ton of code, with each visual component requiring thousands of JavaScript lines to build the DOM nodes, change styles, etc. Before Solid, the only 3rd party library used was jQuery.

I haven't loved working on the UI. Examining the code to understand it, even a small part of it, requires pouring through hundreds or even thousands of lines of code.

So when I was tasked with creating a new UI component, I was very eager to find a framework. But it had to be small, efficient and non-intrusive. Something more invasive would have been a hard sell to management and other developers. Solid popped up in my search and I was intrigued by the performance benchmarks.

====Show Solid Web site, search for performance, and click that link, then the 'official results page'====

It's close to the speed of carefully hand-crafted JavaScript. Efficiency, a small payload, and easy integration into an existing web application convinced me to try it.

# Example Page

Using Solid and JSX, I'm going to create a sample component that's similar to one I created for my job. Here is some static HTML that shows what it will look like:

====Open https://jsfiddle.net/S0Eric/L9b2vdxk/12/ ====

It's a table showing hardware and software settings over the course of an experiment. The columns contain the settings for points in time.

Here is a client-side TypeScript version that creates the same UI dynamically.

====Open https://jsfiddle.net/S0Eric/yvp24mhb/24/ ====

It's the same CSS, but the HTML contains a single placeholder DIV where the component will be rendered, and the TypeScript code generates the UI from data that is just declared at the top. It switches between the two data sets every second by completely re-rendering everything.

Even with a little helper method to create the element nodes, it's hard to tell what the code is doing just by glancing at it. Web developers know HTML, but without a framework and a templating syntax, there is a big gap between the HTML that you prototype, and the resulting code that generates the equivalent UI.

A framework like Solid allows you to write code that generates all or part of your UI with syntax that is not so distant from HTML, and the best part is it makes updating the UI very efficient and straightforward.

# JSX

====Open https://reactjs.org/docs/jsx-in-depth.html====

For the templating syntax, Solid recommends JSX. Solid supports a couple of other templating languages, but JSX looks like the best one.

JSX is a syntax extension to JavaScript, created for the React framework, but it can be used by any framework that supports it. It allows an HTML like syntax to be included in your JavaScript code for describing parts of your UI. It requires a compiler pass to convert the JSX syntax into JavaScript that creates the equivalent DOM nodes.

An example Solid component won't make much sense without some familiarity with JSX. As a matter of fact, JSX is the syntax you use to describe the layout of your UI and Solid is somewhat of a silent actor behind the scenes.

The Babeljs.io web site will let us type in some JavaScript with JSX to see what it compiles to.

====Open https://babeljs.io/ Try it out ====

```

/*************************************/
let x = <div class="title" style="color: green;">Hello!</div>;

/*************************************/
let classname = "title";
function getStyle() {
  return "color: green";
}
let text = "Hello";
let y = <div class={classname} style={getStyle()}>{text + "!"}</div>;

/*************************************/

const OurButton = props => <button style={{color: props.color}}>{props.text}</button>;

const Header = () => (
  <>
    <div class="header-name">Acme Corporation</div>
    <img src="acme.jpg" />
    <div class="header-menu">
      <OurButton text="Home" color="darkgreen" />
      <OurButton text="Products" color="lightgreen" />
      <OurButton text="Contacts" color="lightgreen" />
    </div>
  </>
);
```

JSX looks a lot like HTML, but it isn't really as it gets compiled into JavaScript, and it lets you mix in JavaScript logic and expressions along with the markup syntax.

The JSX compiler simply replaces the JSX syntax in your code with function calls that create the equivalent node structure with nesting of child nodes to any depth. Each resulting JavaScript expression evaluates to a single top level node. So a JSX expression can be used anywhere a JavaScript expression is supported, for example, assigned to a variable, passed as an argument, or returned from a function.

By default, the generated code calls a React's createElement() function to create each node.  To show that JSX isn't just for React, let's add a directive to tell this JSX compiler to use a fictitious function to create the nodes.

```
/** @jsx ourJsxLib.createElem */

```

You could use this feature to invoke your own node creation function to have complete control over how the nodes are created. You could even use JSX for a non-UI related feature that requires generating a tree structure.

The node creation function can create DOM nodes, or virtual DOM nodes, depending on the architecture of the framework. Solid provides its own JSX compiler and support functions to perform some tricks under the covers.

Element attributes, called properties, like class and style, can be specified as string constants, just like in HTML. ====Highlight x expression====

But you can provide values from JavaScript expressions by surrounding them in curly braces. ====Highlight the y expression==== This JSX expression gets its class from a string variable, its style from calling a function, and the child text from a JavaScript string expression. You can see from the generated code how natural that ends up working since it's all JavaScript in the end.

The most common way to use JSX is to define a function that returns a JSX expression. Such a function becomes a re-usable component, as shown by the Header component that contains three OurButton components. The passed properties, like OurButton's text and color, are combined into a single object that is passed to the component as a single **props** argument. See how the OurButton component accesses those passed properties from that **props** object.

Another thing to note is styles can be specified as a string, or as an object with each property of that object specifying a different style. Here is requires double curly braces - the outer ones to indicate this is a JavaScript expression, and the inner ones to indicate this is an object literal.

The Header component is a single-line arrow function, so it doesn't have curly braces, but it's recommended that JSX spread over multiple lines is enclosed in parenthesis.

Finally, JSX has to resolve to a single node, but the Header component contains a list of elements without a natural top-level node to contain them. When this happens, you have to enclose your element list with this empty element, which is a non-node container called a fragment. When a fragment is provided for insertion as a child of another node, it inserts the children, not the fragment.

The OurButton and Header components declared here are implemented as arrow functions. I use them almost exclusivly. Is anyone unfamiliar with arrow function syntax?

```
/*************************************/

// Most traditional named JavaScript function.
function add1(a, b) {
    return a + b;
}

// Anonymous function assigned to add2.
const add2 = function(a, b) {
  return a + b;
}

// Multi-line arrow function.
const add3 = (a, b) => {
  return a + b;
}

// Single-line arrow function. Body expression is the return value.
const add4 = (a, b) => a + b;
```

Arrow function syntax is particularly concise when you want to pass a small anonymous function as an argument. It also fixes issues with "this" binding, making it more intuitive for people who come from other OO languages, so I use it exclusively. Except, I read it shouldn't me used for class methods.

====####====

You'll see how JSX is used in the component I'm about to create, but does anyone have any questions about this so far?

# Node Project

Compiling a Solid project is a little involved:

Coming from a background of statically typed languages, I prefer to use TypeScript.

Webpack performs module resolution, dead code elimination, and minification.

Solid provides its own JSX compiler implemented as a babel plugin.

Solid's "getting started" documentation provides a simple node template project to get started, but I couldn't figure out how to integrate the output into our own build process. So I created a Node project that configures all the required components more explicitly.

I'll post a GitHub link to this small project in case you want to use it as a starting point.

Here is a copy of this project, opened in Visual Studio Code. All its dependencies, except for Solid, is used for building. Only your code, and a small Solid runtime end up in the resulting JavaScript bundle file deployed to production.

Let me first download all dependencies declared in the package.json file.

```
npm install
```

It contains a simple little demo web application that's from a video series that I created. I'll post a link to those videos to the Meetup site.

I'm going to remove the code that is here and replace it with a very simple app.

====delete App.tsx====
====delete store.ts====

See that the index.html file contains a single DIV element where our new component will be rendered.

I'll change the index.tsx file to render a simple component. A javascript file containing JSX will have an extension of dot-jsx, while a TypeScript file containing JSX will have an extension of dot-tsx.

```
import { render } from "solid-js/web";

const Hey = (props: {text: string}) => <strong>Hello {props.text}!</strong>;

window.addEventListener("load", () => {
  render(() => <Hey text="CSJS" />, document.getElementById("root") as Node);
});
```

To start the Webpack development web server, which will build the app, serve it up, and support hot-reload, type this command in the terminal window. This is a shortcut to run the longer command associated with "dev" in the scripts section of the package.json file:

```
npm run dev
```

Now we can open the web app by control-clicking the link shown in the terminal window.

You can write all this in JavaScript if you want, but I'm partial to TypeScript. If you aren't interested in TypeScript, you can mentally remove all standalone type definitions and type annotations, and that would be your equivalent JavaScript.

When the window loads, it invokes Solid's render() funtion, which takes two arguments, the first being a function that returns the JSX expression to render, and the second is the element to render it under. In this case, it'll render the Hey component under the element with the id of "root".

Webpack's development server supports hot-reload, so if I change something and save, it'll recompile and reload automatically.

The Hey component is a simple component, but TypeScript, with strict typing turned on, requires everything have their types declared. The props argument is declared as an object that has a "text" property that is a string.

This works in this simple case, but with Solid, you should use the built-in Component type, giving the type of your argument as a generic type, like this:

```
const Hey: Component<{text:string}> = props => <strong>Hello {props.text}!</strong>;
```

We need to import the Component type declaration from Solid. Again, if you aren't going to use TypeScript, then you won't have to do any of this, except you'll possibly find most bugs at runtime instead of compile time.

As you might imagine, if your component takes many properties, the type passed to Component can get quite large, so I like to declare it as a separate type, like this:

```
type HeyPropsType = {
  text: string,
  color: string
}

const Hey: Component<HeyPropsType> = props => (
  <strong style={{color: props.color}}>
    Hello {props.text}!
  </strong>
);
```

I added a color property to the Hey component. Doing the extra work of adding types provides benefits like this, where the compiler is telling me I forgot to pass the required color property to Hey.

Now let's create our real component. Let's create ExpInfo.tsx.

```
import { Component } from "solid-js"

type ExpInfoPropsType = {
}

export const ExpInfo: Component<ExpInfoPropsType> = props => (
  <strong>Placeholder</strong>
);
```

Then change index.tsx to render this new component instead of Hey:

```
import { render } from "solid-js/web";
import { ExpInfo } from "./ExpInfo";

window.addEventListener("load", () => {
  render(() => <ExpInfo />, document.getElementById("root") as Node);
});
```

Now, let's paste in our big blob of prototype HTML.

```
<div class="expinfo_container">
  <div class="expinfo_titlebar">
    <div class="expinfo_timestamp">hh:mm:ss</div>
    <div class="expinfo_timestamp">00:15:00</div>
    <div class="expinfo_timestamp">00:30:00</div>
    <div class="expinfo_timestamp">00:45:00</div>
    <div class="expinfo_timestamp">01:00:00</div>
    <div class="expinfo_timestamp">01:15:00</div>
    <div class="expinfo_timestamp">01:30:00</div>
    <div class="expinfo_timestamp">01:45:00</div>
    <div class="expinfo_timestamp">02:00:00</div>
  </div>
  <div class="expinfo_datatable">
    <div class="expinfo_descr">Temp</div>
    <div class="expinfo_value">60</div>
    <div class="expinfo_value">61</div>
    <div class="expinfo_value">62</div>
    <div class="expinfo_value">63</div>
    <div class="expinfo_value">64</div>
    <div class="expinfo_value">65</div>
    <div class="expinfo_value">66</div>
    <div class="expinfo_value">67</div>
    <div class="expinfo_descr">Stir Speed</div>
    <div class="expinfo_value">300</div>
    <div class="expinfo_value">303</div>
    <div class="expinfo_value">306</div>
    <div class="expinfo_value">309</div>
    <div class="expinfo_value">311</div>
    <div class="expinfo_value">315</div>
    <div class="expinfo_value">312</div>
    <div class="expinfo_value">299</div>
    <div class="expinfo_descr">Amps</div>
    <div class="expinfo_value">3.5</div>
    <div class="expinfo_value">3.6</div>
    <div class="expinfo_value">3.4</div>
    <div class="expinfo_value">3.3</div>
    <div class="expinfo_value">3.3</div>
    <div class="expinfo_value">3.2</div>
    <div class="expinfo_value">3.1</div>
    <div class="expinfo_value">2.9</div>
  </div>
</div>
```

But it doesn't look like much without CSS.

In the public folder, I'll create expinfo.css and paste in the CSS.

```
.expinfo_container {
  width: 1000px;
  height: 400px;
  background: black;
  color: white;
}

.expinfo_titlebar {
  display: grid;
  grid-template-columns: 200px repeat(8, 1fr);
  width: 100%;
  background: grey;
}

.expinfo_timestamp {
  font-weight: bold;
  color: #3333CC;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 3px 5px 3px 0px;
}

.expinfo_datatable {
  display: grid;
  grid-template-columns: 200px repeat(8, 1fr);
  width: 100%;
}

.expinfo_descr {
  font-weight: bold;
  color: #55CC55;
  text-align: right;
  border-bottom: 0.1px solid grey;
  padding: 1px 5px 1px 5px;
}

.expinfo_value {
  color: #CCCCCC;
  text-align: right;
  border-bottom: 0.1px solid grey;
  padding: 1px 5px 1px 5px;
}
```

We need a reference to the CSS file in index.html.

```
    <link href="./expinfo.css" rel="stylesheet">
```

This project doesn't bundle or hot re-load CSS, so I have to refresh the browser to see these changes.

This is no big trick since the content is static. Of course we want to render the component from data. The magic of a framework like Solid is it figures out how to update the UI efficiently when you change the data behind it. Reactivity is the prize.

To make this work, the data has to be stored in a special state object. Solid provides a function call createState() that creates one of these. Your application can create a single state and store all your data in it, or you can create multiple state objects. That's a design decision that isn't that hard to figure out for your particular app, or change as your design develops.

I like to create a class that manages each state object. I'll call it ExpInfoStore.ts. Does anyone else use classes in their JavaScript code?

Here is a starting point for the code:

```
import { createState } from "solid-js";

type ExpInfoStateType = {
}

export class ExpInfoStore {
  constructor() {
    let [state, setState] = createState<ExpInfoStateType>(this.createInitialState());
  }

  private createInitialState(): ExpInfoStateType {
    return {
    }
  }
}
```

Solid's createState() function takes an object containing the intial state values and returns an array with two elements, what's called a tuple in TypeScript, and we deconstruct those into two variables, **state** and **setState**. **state** is an object your component and other code uses to read values from the state. **setState** is a function that must be used to update the state.

When using TypeScript, the createState() function is given the type of your state object as a generic type argument. I haven't defined any properties for that type yet.

For efficient reactivity, that is, updating the DOM efficiently, Solid wraps the passed initial object in a proxy and returns that, so it knows when and where the state is being read. And the **setState** function makes it obvious to Solid when you are updating it.

In this case, the constructor is creating local variables, but we want to store the returned state in a public class member, and the setState function in a private class member. The **setState** function is stored private because we will expose public helper methods for updating state instead of having external components use setState directly. To tell what type to declare these members as, we can rest our cursor on the returned variables.

```
  state: State<ExpInfoStateType>;
  private setState: SetStateFunction<ExpInfoStateType>;
```

Since we want to store these returned values right in the class members, I'll delete the let keyword and reference the instance members.

```
    [this.state, this.setState] = createState<ExpInfoStateType>(this.createInitialState());
```

Now we have to think about what we put in the state. Since this is TypeScript, we'll first define the type. To get a clue, let's look at that project that generated the web page from data. We need a list of timestamps, and a list of object containing a description and a list of values.

Instead of storing strings for the timestamps, we will store a numeric timestamp for the experiment start time, and then an array of numeric timestamps for each column. This is how timestamps would be stored in a database. The displayed time strings will be the offset of each timestamp from the start of the experiment, calculated inside the component function.

Here is the type declarations for the state that will hold our data. The row type is broken out because I need to use that alone later.

```
type SettingRowType = {
  descr: string,
  values: (number | undefined)[]
}

type ExpInfoStateType = {
  startTimestamp: number;
  timestamps: number[];
  settings: SettingRowType[];
}
```

The reason the values array elements has a type of number **or** undefined is we want to be able to clear a column of data by setting the values in that column to undefined, and the component will display those values as a dash. And the values array can be empty or sparsly populated, and reading a non-populated index will return undefined, so this type matches that JavaScript behavior.

Now let's populate our initial state object that we pass to Solid's createState() function. Emty arrays are fine.

```
  private createInitialState(): ExpInfoStateType {
    return {
      startTimestamp: 0,
      timestamps: [],
      settings: []
    }
  }
```

Let's quickly add the mock data service module to the project since we'll be using it soon. I'll create a MockDataService.ts file and paste in this code:

```
export type SettingsDataType = { description: string; value: number; }[];

export class MockDataService {
  private static readonly SettingsMetadata = [
    { descr: "Image Plane (µm)", isInt: true },
    { descr: "Laser %", isInt: true },
    { descr: "Auto Laser 1 on/0 off", isInt: true },
    { descr: "Triage 1 on/0 off", isInt: true },
    { descr: "Min Black Level", isInt: true },
    { descr: "Image Save Interval", isInt: true },
    { descr: "Images/Interval", isInt: true },
    { descr: "Meas Duration (sec)", isInt: true },
    { descr: "Laser Temperature", isInt: false },
    { descr: "Camera Temperature", isInt: false },
    { descr: "Triage Quality %", isInt: true },
    { descr: "Contrast Range", isInt: true },
    { descr: "Image Spacing on/off", isInt: true },
    { descr: "Auto Laser interval", isInt: true },
    { descr: "Exclude Glare on/off", isInt: true },
    { descr: "Glare Level", isInt: true },
    { descr: "Max Glare %", isInt: true }
  ];

  static getSettingsByTimestamp(timestamp: number): Promise<SettingsDataType> {
    return new Promise(function(resolve) {
      // Return data for this timestamp based on modulo 100 of the timestamp.
      let rootVal = Math.floor(Math.random() * 50);
      let data: SettingsDataType = MockDataService.SettingsMetadata.map((setting, idx) => {
        let val = rootVal + idx;
        return {
          description: setting.descr,
          value: setting.isInt ? val : val + Math.round(Math.random() * 100) / 100
        }
      });
      // Simulate a delay before resolving the promise.
      setTimeout(() => resolve(data), Math.floor(Math.random() * 2000));
    });
  }
}
```

This module exports a class with a single static getSettingsByTimestamp() method that returns a promise that within a random amount of time from 0 to 1 second, it will return random data for a list of hardcoded settings. We'll use this to simulate pulling data from a backend database.

Ok, back to our store class. 

As far as updates go, external code will simulate the user clicking buttons or dragging icons that change what timestamps they want to see. When a timestamp for any particular index changes, a method will be called on our store instance, indicating that the timestamp for index X has changed. The store will clear the values for that column. Then the data service will be invoked to obtain values for all settings for that new timestamp. When that promise resolves, it'll call another method on the store instance to populate that column's values with the returned data.

To support those two operations, here are the methods that will update the state appropriately.

```
  // Initially set the experiment start timestamp.
  setStartTimestamp(timestamp: number) {
    this.setState("startTimestamp", timestamp);
  }

  // Set the timestamp for a particular column index.
  setTimestamp(index: number, timestamp: number) {
    // Tell Solid not to update UI until we are done with all these state updates.
    batch(() => {
      // Update the timestamp at the specified index.
      this.setState("timestamps", index, timestamp);
      // Loop through the settings rows, clearing this column's values.
      for (let i = 0; i < this.state.settings.length; i++) {
        this.setState("settings", i, "values", index, undefined);
      }
    })
  }

  // Set the settings values for a particular column index.
  setSettings(index: number, settings: SettingsDataType) {
    // Tell Solid not to update UI until we are done with all these state updates.
    batch(() => {
      // Loop through the settings, setting the value in each row for the specified column index.
      for (let i = 0; i < settings.length; i++) {
        // Deconstruct the properties out of the settings object.
        const {description, value} = settings[i];
        // For this setting description, look up the row it belongs to.
        const rowIdx = this.descrToRowIndex[description];
        // If we've seen this description before and have a row, then set the value in that row/column.
        if (rowIdx !== undefined) {
          this.setState("settings", rowIdx, "values", index, value);
        }
        else {
          // Add a new row for this description we've not seen before.
          this.descrToRowIndex[description] = this.state.settings.length;
          const values = [];
          values[index] = value;
          const newRow: SettingRowType = { descr: description, values: values }
          this.setState("settings", [...this.state.settings, newRow]);
        }
      }
    });
  }
```

Solid's batch() function is how you tell it to not update the UI until all the changes performed in the passed function are complete. This may not be required in this case, but it is required when you are making changes to multiple state properties that have dependencies between them.

I'll resolve the missing module imports as I go through the added code.

This code illustrates a number of powerful overloads that Solid's **setState** function provides. You can pass an object to it containing the properties you want to update, but I generally found the overloads that take a propery name as a string more convenient when I'm setting a specific value deep in the structure.

setStartTimestamp() uses a simple overload that specifies the property name to update and the value to assign.

setTimestamp() uses a overload of **setState** for updating an array where the index to update is specified after the property name. When updating the **values** array that is inside the settings array, you can see this overload takes the indexes after each property name.

This really blew my mind when I first saw it. I didn't know TypeScript supported such powerful type definitions. Just by passing the state type definition as a generic type parameter to createState(), the returned **setState** function has type information transferred to it that invalid calls to it are flagged by the compiler. Watch what happens when I use an invalid property name, or put in an extra argument, or take one out.

I looked at Solid's source code for the setState() function and it was the most complex TypeScript type definitions I've ever see, and I wasn't able to follow it. But luckily, I don't have a need to create a powerful API like this.

setSettings() is a little more complex because it may optionally add rows to the state's settings property if a row for a particular description doesn't exist already. Given a description, this object will map that to a row index, or if the description isn't in the object, it means a row has to be added.

```
  private descrToRowIndex: { [descr: string]: number } = {};
```

This type syntax says this object contains any nummber of properties that map to numers.

Since we want the state to be updated outside of our ExpInfo component, we'll create it outside of the component and pass it in. So we'll add this code to index.tsx.

```
import { ExpInfoStore } from "./ExpInfoStore";
import { MockDataService } from "./MockDataService";

let store = new ExpInfoStore();
```

Then we'll pass the store to the ExpInfo component, so it can use it.

```
  render(() => <ExpInfo store={store} />, document.getElementById("root") as Node);
```

It'll give us an error until we change ExpInfo to take that property.

```
import { ExpInfoStore } from "./ExpInfoStore";

type ExpInfoPropsType = {
  store: ExpInfoStore;
}
```

Now we'll add a function to index.tsx that populates the state with data.

```
const populateState = (timestampGapMinutes: number) => {
  for (let i = 0; i < 8; i++) {
    let timestamp = startTimestamp + (i+1) * timestampGapMinutes * 60000;
    store.setTimestamp(i, timestamp);
    MockDataService.getSettingsByTimestamp(timestamp).then(settings => {
      store.setSettings(i, settings);
    });
  }
}
```

And invoke that function when the page loads, with a 2 second delay.

```
  setTimeout(() => populateState(5), 2000);
```

Now that we have some data in the state, we have to change our component to render its UI from that data.

Because I'll need some helper functions in this component, I'll change it to a multiline function.

And since the timestamps can be undefined, or are numbers and I need the start timestamp subtracted from them and formatted, and the values need special formatting logic, here are two helper function to do that.

```
  // Format the timestamp as HH:MM:SS or __:__:__ if undefined.
  const fmtTs = (idx: number) => {
    const timestamp = props.store.state.timestamps[idx];
    if (timestamp !== undefined) {
      // Get number of milliseconds between the timestamp and the start time.
      let time = timestamp > props.store.state.startTimestamp ? timestamp - props.store.state.startTimestamp : 0;
      // Round to nearest second.
      time = Math.round(time / 1000) * 1000;
      // Return formatted string, just hh:mm:ss.
      return new Date(time).toISOString().substring(11, 19);
    }
    else {
      return "__:__:__";
    }
  }

  // Display the value as a string, or "-" if undefined.
  const fmtValue = (val: number | undefined) => val !== undefined ? val.toString() : "-";
```

We'll replace the 8 static DIVs containing timestamps to a loop that generates them from the state's **timestamps** property. Solid provides a special For component that loops over a collection. But since the timestamp array may be empty or sparsly populated, but we want to check all 8 indexes, we'll loop over a hardcoded array from 0 to 7.

```
        <For each={[0, 1, 2, 3, 4, 5, 6, 7]}>
          {idx => <div class="expinfo_timestamp">{fmtTs(idx)}</div>}
        </For>
```

Now it displays the missing timestamp placeholders for 2 seconds and then displays the time offsets.

The For component requires an "each" property that specifies the collection to iterate over, in this case a hardcoded array of indexes. The child expression inside the For is a function that is passed each element as the For component iterating over the array, and that function returns the JSX to use.

Now to render the DIV elements for the values requires nested For loops.

```
        <For each={props.store.state.settings}>
          {setting => (
            <>
              <div class="expinfo_descr">{setting.descr}</div>
              <For each={[0, 1, 2, 3, 4, 5, 6, 7]}>
                {idx => (
                  <div class="expinfo_value">{setting.values[idx]}</div>
                )}
              </For>
            </>
          )}
        </For>
```

The outer For iterates over each setting row, and the inner For iterates over each value for that setting.

Now we're all set up for reactivity. It initially renders without any data, and then renders the data as the mock data service delivers it.






This function is defined inside the component so it can reference the store property passed in the props argument. The FormatTime function can be implemented outside the component since it is passed everything it needs. I'll put it at the bottom.

```
const FormatTime = (timestamp: number, startTimestamp: number) => {
  // Get number of milliseconds between the timestamp and the start time.
  let time = timestamp > startTimestamp ? timestamp - startTimestamp : 0;
  // Round to nearest second.
  time = Math.round(time / 1000) * 1000;
  // Return formatted string, just hh:mm:ss.
  return new Date(time).toISOString().substring(11, 19);
}
```

Let's change the store to make the timestamps 5 minutes apart instead of 15 to make sure it's working.

Now let's add the rest of the data to the store. We first need to declare the type of this property to store in the state. Looking at the project again that generated the web page from data, here is the new property type:

```
  settings: { descr: string, values: number[] }[];
```

This means the settings property is an array of objects, where each object has a description string and an array of values.

In createInitialState(), we'll initialize that property to an empty array.

```
      settings: []
```

Then we'll update the constructor to put in some dummy data for now.

```
    // Fill in some dummy row data.
    this.setState("settings", 0, "descr", "Temp");
    this.setState("settings", 0, "values", [60, 61, 62, 63, 64, 65, 66, 67]);
    this.setState("settings", 0, "descr", "Stir Speed");
    this.setState("settings", 0, "values", [300, 303, 306, 309, 311, 315, 312, 299]);
    this.setState("settings", 0, "descr", "Amps");
    this.setState("settings", 0, "values", [3.5, 3.6, 3.4, 3.3, 3.3, 3.2, 3.1, 2.9]);
```

Now we'll change our component to render from this data.

```
      <div class="expinfo_datatable">
        <For each={props.store.state.settings}>
          {setting => (
            <>
              <div class="expinfo_descr">{setting.descr}</div>
              <For each={setting.values}>
                {v => (
                  <div class="expinfo_value">{v}</div>
                )}
              </For>
            </>
          )}
        </For>
      </div>
```


To simulate returning real data from a database or backend service, I'll create a class called MockDataService that will return dummy data for a specified timestamp.

```
type SettingType = {
  description: string;
  value: number;
}

export class MockDataService {
  private static readonly SettingsMetadata = [
    { descr: "Image Plane (µm)", isInt: true },
    { descr: "Laser %", isInt: true },
    { descr: "Auto Laser 1 on/0 off", isInt: true },
    { descr: "Triage 1 on/0 off", isInt: true },
    { descr: "Min Black Level", isInt: true },
    { descr: "Image Save Interval", isInt: true },
    { descr: "Images/Interval", isInt: true },
    { descr: "Meas Duration (sec)", isInt: true },
    { descr: "Laser Temperature", isInt: false },
    { descr: "Camera Temperature", isInt: false },
    { descr: "Triage Quality %", isInt: true },
    { descr: "Contrast Range", isInt: true },
    { descr: "Image Spacing on/off", isInt: true },
    { descr: "Auto Laser interval", isInt: true },
    { descr: "Exclude Glare on/off", isInt: true },
    { descr: "Glare Level", isInt: true },
    { descr: "Max Glare %", isInt: true }
  ];

  static getSettingsByTimestamp(timestamp: number) {
    return new Promise(function(resolve) {
      // Return data for this timestamp based on modulo 100 of the timestamp.
      let rootVal = Math.floor(timestamp % 100);
      let data: SettingType[] = MockDataService.SettingsMetadata.map((setting, idx) => {
        let val = rootVal + idx;
        return {
          description: setting.descr,
          value: setting.isInt ? val : val + Math.round(Math.random() * 100) / 100
        }
      });
      // Simulate a delay between 0 and 1 seconds before resolving the promise.
      setTimeout(() => resolve(data), Math.floor(Math.random() * 1000));
    });
  }
}
```

I'll remove all the code from the store that populates it with dummy data.

After saving, you see the component is rendered without data.

Now I'll add code to index.tsx to asynchronously populate the state with data over time.

```
```


In my employer's application, the user can manually drag markers around on an adjacent chart to change where the timestamps are. Each marker is assigned a fixed index, 0-7, but what if we want the component to automatically sort by timestamp, so when they reorder the markers, the columns automatically reorder.

