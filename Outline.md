# Introduction

====Show BlazeMetrics.com====

I haven't been a member of this Meetup group long enough to get a handle on the general experience of the group. So if I'm going into too little or too much detail, please don't hesitate to give feedback right away. And to not run too long, I'll try to keep it moving, but please don't hesitate to ask questions if something doesn't make sense.

Solid is a client side framework where the components managed by Solid are rendered and updated completely in the browser. If anyone isn't sure how client vs. server side rendering differs, I can talk about that briefly.

====Open https://javatutorial.net/wp-content/uploads/2018/02/traditional-page-lifecycle-vs-spa-lifecycle.png====

Instead of the web server refreshing the whole web page every time something changes in the UI, there is only an initial request that typically contains a lot of JavaScript and supporing files, and then the UI is rendered and managed in the browser. Interaction with the server from then on is done by sending and receiving data, not web pages. A hybrid approach may make sense in some cases also.

Let's say you have a web application that needs to be very responsive. For example, you have a lot of data displayed and you want the user to be able to sort by different columns, analyze, or filter the data, and see the results very quickly. Implementing this client side will allow it to respond to user interactions very quickly without ever having to talk to the server.

You can even write web applications that run offline, without a network connection, storing data in local storage and synchronizing when back online.

This approach can **also** be used to create cross-platform apps, with frameworks like Apache Cordova for mobile, and Electron for desktop. They let you use your HTML/CSS/JavaScript knowledge to create an app that runs anywhere.

====####====

The company I work for makes microscope-like devices that monitor chemical experiments, and production processes, continually capturing and analyzing images to measure particle sizes. The application is written in C++ for the core logic, with the UI implemented in an embedded Chromium window.

Our UI shows images, charts, and tables of data, all dynamically generated by JavaScript. There's a ton of code, with each visual component requiring thousands of lines to build the DOM nodes, change styles, etc. The only 3rd party library used is jQuery.

The person that wrote most of the UI started many years ago and did an amazing amount of work, but I haven't loved working on it. Examining the code to understand it, even a small part of it, requires scrolling all over the place. And I always find unexpected gotchas. For example, I'll change a function that enables or disables a button or a textbox and find that it doesn't work because the state of that component is also set in two to three other places, and some other module is overwriting my DOM update at a later time. This may be typical of older code-bases.

Has anyone else worked on this sort of hand-written client side application and encountered this sort of thing?

So when I was tasked with creating a new UI component, I was very eager to find a framework. But it had to be small, efficient and non-intrusive. Something more invasive would have been a hard sell to management and other developers. Solid popped up in my search and I was intrigued by the performance benchmarks.

====Show Solid Web site, search for performance, and click that link, then the 'official results page'====

It's close to the speed of carefully crafted JavaScript. Efficiency, a small payload, and easy integration into an existing application convinced me to try it.

# Example Page

Using Solid and JSX, I'm going to create a sample component that's similar to one I created for my job. Here is some static HTML that shows what it will look like:

====Open https://jsfiddle.net/S0Eric/L9b2vdxk/12/ ====

It's a table showing hardware and software settings over the course of an experiment. The columns contain the settings for points in time throughout the experiment.

Here is a client-side TypeScript version of this sample page, to show how hard it is to correlate the generated DOM structure with the code.

====Open https://jsfiddle.net/S0Eric/yvp24mhb/24/ ====

It's the same CSS, but the HTML contains a single placeholder DIV where the component will be rendered, and the TypeScript code generates the UI from data that is just declared at the top. It switches between the two data sets every second by completely re-rendering everything.

Even with a little helper method to create the element nodes, it's hard to tell what the code is doing just by glancing at it. Web developers know HTML, but without a framework and a templating syntax, there is a big gap between the HTML that you prototype, and the resulting code that generates the equivalent DOM node structure.

A framework like Solid allows you to write code that generates all or part of your UI with syntax that is not so distant from HTML, and the best part is it makes updating the UI very efficient and straightforward.

# JSX

For the templating syntax, Solid recommends JSX. It supports a couple of other templating languages, but JSX looks superior to me.

JSX is a syntax extension to JavaScript, created for the React framework, but it can be used by any framework that supports it. It allows an HTML like syntax to be included in your JavaScript code for describing parts of your UI. It requires a compiler pass to convert the JSX syntax into JavaScript that creates the equivalent DOM nodes.

An example Solid component won't make much sense without some familiarity with JSX. As a matter of fact, JSX is the syntax you use to express the layout of your UI and Solid is somewhat of a silent actor behind the scenes.

Babeljs.io will let us type in some JavaScript with JSX to see what it compiles to.

====Open https://babeljs.io/ Try it out ====

```
let x = <div class="title" style="color: green;">Hello!</div>;
```

Without "React" support turned on, the JSX expressions makes for invalid JavaScript. This looks like HTML, but it isn't really as it gets compiled into JavaScript, and JSX lets you mix in JavaScript logic and expressions with the markup.

```
/*************************************/
let classname = "title";
function getStyle() {
  return "color: green";
}
let text = "Hello";
let y = <div class={classname} style={getStyle()}>{text + "!"}</div>;
```

This JSX expression is the same as the one above, but it replaces the class, style, and text string constants with a string variable, a function call, and a string expression. To use a JavaScript expression, simply surround it with curly braces.

The right side shows the resulting JavaScript after compiling. By default, it generates code that invokes a React function to create the equivalent node structure, and the resulting top level node becomes the value that is used as a replacement for the JSX expression. This means JSX can be used wherever a JavaScript expression is allowed, for example, assigned to a variable, passed as an argument, or returned from a function.

To show that JSX isn't just for React, let's add a directive to tell this JSX compiler to use a fictitious function to create the nodes.

```
/** @jsx ourJsxLib.createElem */

```

Now it calls this function to create the nodes instead of React's. This isn't exactly how Solid does it, as it provides its own JSX compiler, but it makes the point that JSX isn't tied only to React.

The node create function can create DOM nodes, or it can create other types of nodes, for example virtual DOM nodes. We can talk about how Solid compares to using a virtual DOM if we have time at the end.

Here is a more realistic, if incomplete, example.

```
/*************************************/

const OurButton = props => <button style={{color: props.color}}>{props.text}</button>;

const Header = () => (
  <>
    <div class="header-name">Acme Corporation</div>
    <img src="acme.jpg" />
    <div class="header-menu">
      <OurButton text="Home" color="darkgreen" />
      <OurButton text="Products" color="lightgreen" />
      <OurButton text="Contacts" color="lightgreen" />
    </div>
  </>
);
```

The OurButton and Header components declared here are implemented as arrow functions. Should I talk about arrow functions briefly?

```
/*************************************/

// Most traditional named JavaScript function.
function add1(a, b) {
    return a + b;
}

// Anonymous function assigned to add2.
const add2 = function(a, b) {
  return a + b;
}

// Multi-line arrow function.
const add3 = (a, b) => {
  return a + b;
}

// Single-line arrow function. Body expression is the return value.
const add4 = (a, b) => a + b;
```

Arrow function syntax is particularly concise when you want to pass a small anonymous function as an argument. It also fixes issues with "this" binding, making it more intuitive for people who come from other OO languages, so I use it exclusively. Except, I read it shouldn't me used for class methods.

Ok, back to the JSX.

====####====

This is a more typical scenario where a function returns JSX. A very useful thing about these functions is they are also reusable components. If an element tag isn't one of the standard HTML tags, it assumes it's a re-usable component, which is simply a function that it'll call to render it.

Note how the Header component includes three OurButton components. Any number of properties can be passed, which all become members of an object that is passed as a single argument. In this case OurButton takes a text and color property. The OurButton component references those properties through the object that is passed to it.

When specifying a "style" property, you can specify a string, as shown in the image element, or as an object, as shown in OurButton. Notice the double curly braces, the outer ones indicating this is a JavaScript expression, and the inner ones indicating this is an object literal, where each property specifies a different style.

The Header component returns a single expression, so it doesn't use curly braces, but when you have a multiline JSX expression, it's recommended to enclose it in parenthesis.

Another strange thing here is the empty angle brackets. Because all JSX expressions result in a reference to a top level node object, if you don't have a natural top level node, you enclose your list of nodes in what is called a fragment - these empty angle brackets. You can see that the function call on the right passes a special constant to indicate it's a fragment, and when this expression is inserted into a larger tree of nodes, it will insert the children of the fragment. The fragment is just a container. If I comment out the fragment wrapper, the JSX compiler shows an error because a JSX expression can't result in a list of elements.

You'll see how JSX is used in the component I'm about to create, but does anyone have any questions about this so far?

# Node Project

Compiling a Solid project is a little involved:

Coming from a background of statically typed languages, I prefer to use TypeScript.

Webpack performs module resolution, dead code elimination, and minification.

Solid provides its own JSX compiler implemented as a babel plugin.

Solid's "getting started" documentation provides a simple node template project to get started, but I couldn't figure out how to integrate the output into our own build process. So I created a Node project that configures all the required components more explicitly.

I'll post a link to this small project in case you want to use it as a starting point.






Let's quickly create a blank Node project. A simple Node project starts out as a single folder with a project.json file.

```
mkdir proj1
cd proj1
npm init
code .
```

Now to add tools and dependencies that the project can use, for example, let's add the latest TypeScript compiler.

```
npm install --save-dev typescript
```

This installs TypeScript, but it won't be deployed to production, it'll only be used to build the source code, so I made it a "devDependency". You can see the project file was updated.

You add any tools you want to use in this way, add configuration files for them, and use them in the project.

You add sections to the project.json file manually for some tools, and some require their own config files.

If you check out a Node project, from GitHub for example, and the dependencies haven't been downloaded, you use this command to download them all:

```
npm install
```

There are many project templates you can use. Solid provides a TypeScript starter project that you can easily create with one command.

```
cd ..
npm init solid app-ts my-app
code .
```

But this project includes a dependency called "solid-scripts" that is handy to get going, but doesn't allow the control over the settings that I wanted, so I created my own project that more explicitly performs the build process.

# Background (continued)

**Show 01-HTML**

This first project doesn't have any client side code, and is a simple static web page, served up by a web server. In this case, the web server used is provided by webpack. It provides hot reload and is nice for development.

Back to the node project... The "scripts" section can contain any number of command that you configure for convenient use.

In this case, I've defined "start" to launch the webpack development web server, "build-dev" to build the source bundle it into a single JS file that contains source maps for easy debugging, "build" to create a single JS file that is very small and intended for production use, and "watch" that watches the source files and recompiles when they change, for when you are debugging outside of VS code.

To run any of these commands, use "npm run", so to start the web server:

```
npm run start
```

This simply executes the command defined by the "start" script entry.

By the way, I've started using grid for layout, so the table layout is defined in the CSS file, and the HTML just contains lists of DIVs.

Now onto client side JS...

**Stop the web server, cd ..\02-JS-Template**

**Show 02-JS-Template**

This is a weird one that isn't that relevant, except to show a way for the client side to render the same table, but from HTML stored in a string variable.

Solid uses templates internally to create parts of components when they are rendered. Somewhere on Solid's web site said using templates, as opposed to document.createElement, provided a 5-8% improvement in rendering speed. document.createElement() just creates a single DOM node, and doing anything to it, like setting an attribute, or adding children, requires extra steps, while a template can contain a larger HTML fragment. It makes sense that re-using a template over and over is faster.

**Show index.html**

This project's HTML file contains a single DIV placeholder where the content will be rendered by JS.

**Show the single source file index.tsx - explain it**

**Start the project and open Edge development tools to see the source**

Now onto a project that builds the DOM nodes one at a time...

**Show 03-JSX-Build**

This project has the same index.html file with just a placeholder.

The index.tsx file contains two pairs of variables containing the data to render.

**Explain the intex.tsx file**

The UI layout is created by the renderTableControl() function. I'm curious how many people have built or worked on something like this?

Frankly, it's hard to see the UI from looking at the code. You can structure an application like this decently, but it can require a lot of lines of code - creating each element, setting attributes, adding to parent controls, etc.

When it is run, it renders one set of numbers, and then after 5 seconds it renders the second, and then switches every 2.5 seconds.

# Frameworks

A framework typically supports some sort of template language so your UI is described with an HTML like syntax, with JavaScript mixed in for that parts that are dynamic.

https://www.infoworld.com/article/3606737/angular-react-vue-javascript-frameworks-compared.html

This article shows a simple button component written using Angular, React, and View.

**Scroll down to the Angular example**

There's the UI template, easy to see, with the JavaScript stuff mixed in. The template includes calls to two functions, and the current counter is rendered at the bottom.

**Scroll down to the React example**

This looks very similar to Solid using JSX. For the templating piece, Solid also supports tagged template literals, and a hyperscript variant. I haven't used those, Solid recommends JSX for better performance, and I think JSX is easy to understand and use. More on JSX later.

**Scroll through the examples**

So Angular components are implemented as classes, React components are functions, and Vue components are defined by objects. But they all have some templating syntax, with JavaScript mixed in.

# Functional

No matter how the code is organized, you can look at it in a functional way - given the current state, the UI is generated by a hierarchy of functions.

The state is just the raw data that is displayed, and any other data that's required to generate the UI. For example, in a todo-list application, the list of todo items are part of the state, and if the application has a "Simple" and "Expert" mode, that could be stored in the state as a single boolean value.

This is going to get formal for a minute, but I found these ideas helpful.

**Show slide 4**

This equation says, given the current state, and an event or action, the next state of the application is calculated by equation R. Events can be internal or external - for example, the user could delete a todo item, or a new one could come in over the internet.

In the sample Solid project I'll create, there won't be a single function that applies an event to state, but it'll be a single software component, specifically a class.

**Show slide 5**

This equation says, given the current state, the function F generates the UI. F isn't typically a single function, but is a composition of components that together render the complete UI.

**Show slide 6**

This equation puts the two together. Working from the inside out, this is saying that the current state and an event are applied by function R to create a new state, that state is then applied by function F to generate the UI.

Applying this equation to every event drives your application forward in time, responding to actions and event, and properly displaying the appropriate UI.

You can't avoid writing the logic that updates state, or the logic that generates the UI, but if that is all you have to write, and skip the logic that determines when and what gets updated, then that would be almost too good to be true.

# Performance

The last project we looked at had static state, but the UI is completely generated by the single function renderTableControl.

Besides the source being hard to read and update, it also doesn't perform well. Every time it renders the page, the whole DOM is deleted and re-created. This isn't a problem with a tiny app like this, but any large app wants the UI to be as efficient and responsive as possible.

Updating the DOM is expensive because the browser has to layout and render the parts that change. The trick is to make minimal changes to the DOM. That may not sound hard to do, but it can be complicated. What if your app is showing a list of items, and you change the sort rules. Does it render the whole list, or does it rearrange the existing items in the DOM? The rearrange logic would be tricky. Let's say someone changes the color theme from light to dark, does everything re-render, or can you write the code that knows every style that has to change?

Last month there was mention of the virtual DOM. This technique is interesting, and is a performance improvement, even though it sounds like a lot of work. The code that generates the UI doesn't change the DOM directly, but instead renders into a tree in application memory. There can be localized optimizations, but any component that changes gets completely re-rendered to memory, but it's just allocating objects and building a tree in memory, so it's relatively fast. Then it compares the virtual DOM with the actual DOM, or I think the previously rendered memory tree, to see what elements have to be added, deleted, attributes changes, etc. So, for example, if you change the color theme, it'll re-render the whole UI, and then during the comparison phase will find what color attributes have to change.

If the app doesn't use a framework, like most of the codebase I work on, when the color theme changes, a method to set theme colors is called on the top level component, and that component knows what child components need to be notified, etc., all the way down to the smallest component.

Solid takes a different approach. I'll show you later how it doesn't implement a virtual DOM, but instead figures out the minimum DOM changes directly from the changes you make to your state.

