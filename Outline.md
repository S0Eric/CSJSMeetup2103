# Introduction

====Show BlazeMetrics.com====

I haven't been a member of this Meetup group long enough to get a handle on the general experience of the group. So if I'm going into too little or too much detail, please don't hesitate to give feedback right away. And to not run too long, I'll try to keep it moving, but please don't hesitate to ask questions if something doesn't make sense.

Solid is a client side framework where the components managed by Solid are rendered and updated completely in the browser. If anyone isn't sure how client vs. server side rendering differs, I can talk about that briefly.

====Open https://javatutorial.net/wp-content/uploads/2018/02/traditional-page-lifecycle-vs-spa-lifecycle.png====

Instead of the web server refreshing the whole web page every time something changes in the UI, there is only an initial request that typically contains a lot of JavaScript and supporing files, and then the UI is rendered and managed in the browser. Interaction with the server from then on is done by sending and receiving data, not web pages. A hybrid approach may make sense in some cases also.

Let's say you have a web application that needs to be very responsive. For example, you have a lot of data displayed and you want the user to be able to sort by different columns, analyze, or filter the data, and see the results very quickly. Implementing this client side will allow it to respond to user interactions very quickly without ever having to talk to the server.

You can even write web applications that run offline, without a network connection, storing data in local storage and synchronizing when back online.

This approach can **also** be used to create cross-platform apps, with frameworks like Apache Cordova for mobile, and Electron for desktop. They let you use your HTML/CSS/JavaScript knowledge to create an app that runs anywhere.

====####====

The company I work for makes microscope-like devices that monitor chemical experiments, and production processes, continually capturing and analyzing images to measure particle sizes. The application is written in C++ for the core logic, with the UI implemented in an embedded Chromium window.

Our UI shows images, charts, and tables of data, all dynamically generated by JavaScript. There's a ton of code, with each visual component requiring thousands of lines to build the DOM nodes, change styles, etc. The only 3rd party library used is jQuery.

The person that wrote most of the UI started many years ago and did an amazing amount of work, but I haven't loved working on it. Examining the code to understand it, even a small part of it, requires scrolling all over the place. And I always find unexpected gotchas. For example, I'll change a function that enables or disables a button or a textbox and find that it doesn't work because the state of that component is also set in two to three other places, and some other module is overwriting my DOM update at a later time. This may be typical of older code-bases.

Has anyone else worked on this sort of hand-written client side application and encountered this sort of thing?

So when I was tasked with creating a new UI component, I was very eager to find a framework. But it had to be small, efficient and non-intrusive. Something more invasive would have been a hard sell to management and other developers. Solid popped up in my search and I was intrigued by the performance benchmarks.

====Show Solid Web site, search for performance, and click that link, then the 'official results page'====

It's close to the speed of carefully crafted JavaScript. Efficiency, a small payload, and easy integration into an existing application convinced me to try it.

# Example Page

Using Solid and JSX, I'm going to create a sample component that's similar to one I created for my job. Here is some static HTML that shows what it will look like:

====Open https://jsfiddle.net/S0Eric/L9b2vdxk/12/ ====

It's a table showing hardware and software settings over the course of an experiment. The columns contain the settings for points in time throughout the experiment.

Here is a client-side TypeScript version of this sample page, to show how hard it is to correlate the generated DOM structure with the code.

====Open https://jsfiddle.net/S0Eric/yvp24mhb/24/ ====

It's the same CSS, but the HTML contains a single placeholder DIV where the component will be rendered, and the TypeScript code generates the UI from data that is just declared at the top. It switches between the two data sets every second by completely re-rendering everything.

Even with a little helper method to create the element nodes, it's hard to tell what the code is doing just by glancing at it. Web developers know HTML, but without a framework and a templating syntax, there is a big gap between the HTML that you prototype, and the resulting code that generates the equivalent DOM node structure.

A framework like Solid allows you to write code that generates all or part of your UI with syntax that is not so distant from HTML, and the best part is it makes updating the UI very efficient and straightforward.

# JSX

For the templating syntax, Solid recommends JSX. It supports a couple of other templating languages, but JSX looks superior to me.

JSX is a syntax extension to JavaScript, created for the React framework, but it can be used by any framework that supports it. It allows an HTML like syntax to be included in your JavaScript code for describing parts of your UI. It requires a compiler pass to convert the JSX syntax into JavaScript that creates the equivalent DOM nodes.

An example Solid component won't make much sense without some familiarity with JSX. As a matter of fact, JSX is the syntax you use to express the layout of your UI and Solid is somewhat of a silent actor behind the scenes.

Babeljs.io will let us type in some JavaScript with JSX to see what it compiles to.

====Open https://babeljs.io/ Try it out ====

```
let x = <div class="title" style="color: green;">Hello!</div>;
```

Without "React" support turned on, the JSX expressions makes for invalid JavaScript. This looks like HTML, but it isn't really as it gets compiled into JavaScript, and JSX lets you mix in JavaScript logic and expressions with the markup.

```
/*************************************/
let classname = "title";
function getStyle() {
  return "color: green";
}
let text = "Hello";
let y = <div class={classname} style={getStyle()}>{text + "!"}</div>;
```

This JSX expression is the same as the one above, but it replaces the class, style, and text string constants with a string variable, a function call, and a string expression. To use a JavaScript expression, simply surround it with curly braces.

The right side shows the resulting JavaScript after compiling. By default, it generates code that invokes a React function to create the equivalent node structure, and the resulting top level node becomes the value that is used as a replacement for the JSX expression. This means JSX can be used wherever a JavaScript expression is allowed, for example, assigned to a variable, passed as an argument, or returned from a function.

To show that JSX isn't just for React, let's add a directive to tell this JSX compiler to use a fictitious function to create the nodes.

```
/** @jsx ourJsxLib.createElem */

```

Now it calls this function to create the nodes instead of React's. This isn't exactly how Solid does it, as it provides its own JSX compiler, but it makes the point that JSX isn't tied only to React.

The node create function can create DOM nodes, or it can create other types of nodes, for example virtual DOM nodes. We can talk about how Solid compares to using a virtual DOM if we have time at the end.

Here is a more realistic, if incomplete, example.

```
/*************************************/

const OurButton = props => <button style={{color: props.color}}>{props.text}</button>;

const Header = () => (
  <>
    <div class="header-name">Acme Corporation</div>
    <img src="acme.jpg" />
    <div class="header-menu">
      <OurButton text="Home" color="darkgreen" />
      <OurButton text="Products" color="lightgreen" />
      <OurButton text="Contacts" color="lightgreen" />
    </div>
  </>
);
```

The OurButton and Header components declared here are implemented as arrow functions. Should I talk about arrow functions briefly?

```
/*************************************/

// Most traditional named JavaScript function.
function add1(a, b) {
    return a + b;
}

// Anonymous function assigned to add2.
const add2 = function(a, b) {
  return a + b;
}

// Multi-line arrow function.
const add3 = (a, b) => {
  return a + b;
}

// Single-line arrow function. Body expression is the return value.
const add4 = (a, b) => a + b;
```

Arrow function syntax is particularly concise when you want to pass a small anonymous function as an argument. It also fixes issues with "this" binding, making it more intuitive for people who come from other OO languages, so I use it exclusively. Except, I read it shouldn't me used for class methods.

Ok, back to the JSX.

====####====

This is a more typical scenario where a function returns JSX. A very useful thing about these functions is they are also reusable components. If an element tag isn't one of the standard HTML tags, it assumes it's a re-usable component, which is simply a function that it'll call to render it.

Note how the Header component includes three OurButton components. Any number of properties can be passed, which all become members of an object that is passed as a single argument. In this case OurButton takes a text and color property. The OurButton component references those properties through the object that is passed to it.

When specifying a "style" property, you can specify a string, as shown in the image element, or as an object, as shown in OurButton. Notice the double curly braces, the outer ones indicating this is a JavaScript expression, and the inner ones indicating this is an object literal, where each property specifies a different style.

The Header component returns a single expression, so it doesn't use curly braces, but when you have a multiline JSX expression, it's recommended to enclose it in parenthesis.

Another strange thing here is the empty angle brackets. Because all JSX expressions result in a reference to a top level node object, if you don't have a natural top level node, you enclose your list of nodes in what is called a fragment - these empty angle brackets. You can see that the function call on the right passes a special constant to indicate it's a fragment, and when this expression is inserted into a larger tree of nodes, it will insert the children of the fragment. The fragment is just a container. If I comment out the fragment wrapper, the JSX compiler shows an error because a JSX expression can't result in a list of elements.

You'll see how JSX is used in the component I'm about to create, but does anyone have any questions about this so far?

# Node Project

Compiling a Solid project is a little involved:

Coming from a background of statically typed languages, I prefer to use TypeScript.

Webpack performs module resolution, dead code elimination, and minification.

Solid provides its own JSX compiler implemented as a babel plugin.

Solid's "getting started" documentation provides a simple node template project to get started, but I couldn't figure out how to integrate the output into our own build process. So I created a Node project that configures all the required components more explicitly.

I'll post a link to this small project in case you want to use it as a starting point.

Here is a copy of this project, opened in Visual Studio Code. All its dependencies, except for Solid, is used for building. Only your code, and a small Solid runtime end up in the resulting JavaScript bundle file deployed to production.

Let me first download all dependencies declared in the package.json file.

```
npm install
```

It contains a simple little demo web application that's from a video series that I created. I'll post a link to those videos to the Meetup site.

I'm going to remove the code that is here and replace it with a very simple app.

====delete App.tsx====
====delete store.ts====

See that the index.html file contains a single DIV element where our new component will be rendered.

I'll change the index.tsx file to render a simple component. A javascript file containing JSX will have an extension of dot-jsx, while a TypeScript file containing JSX will have an extension of dot-tsx.

```
import { render } from "solid-js/web";

const Hey = (props: {text: string}) => <strong>Hello {props.text}!</strong>;

window.addEventListener("load", () => {
  render(() => <Hey text="CSJS" />, document.getElementById("root") as Node);
});
```

To start the Webpack development web server, which will build the app, serve it up, and support hot-reload, type this command in the terminal window. This is a shortcut to run the longer command associated with "dev" in the scripts section of the package.json file:

```
npm run dev
```

Now we can open the web app by control-clicking the link shown in the terminal window.

You can write all this in JavaScript if you want, but I'm partial to TypeScript. If you aren't interested in TypeScript, you can mentally remove all standalone type definitions and type annotations, and that would be your equivalent JavaScript.

When the window loads, it invokes Solid's render() funtion, which takes two arguments, the first being a function that returns the JSX expression to render, and the second is the element to render it under. In this case, it'll render the Hey component under the element with the id of "root".

Webpack's development server supports hot-reload, so if I change something and save, it'll recompile and reload automatically.

The Hey component is a simple component, but TypeScript, with strict typing turned on, requires everything have their types declared. The props argument is declared as an object that has a "text" property that is a string.

This works in this simple case, but with Solid, you should use the built-in Component type, giving the type of your argument as a generic type, like this:

```
const Hey: Component<{text:string}> = props => <strong>Hello {props.text}!</strong>;
```

We need to import the Component type declaration from Solid. Again, if you aren't going to use TypeScript, then you won't have to do any of this, except you'll possibly find most bugs at runtime instead of compile time.

As you might imagine, if your component takes many properties, the type passed to Component can get quite large, so I like to declare it as a separate type, like this:

```
type HeyPropsType = {
  text: string,
  color: string
}

const Hey: Component<HeyPropsType> = props => (
  <strong style={{color: props.color}}>
    Hello {props.text}!
  </strong>
);
```

I added a color property to the Hey component. Doing the extra work of adding types provides benefits like this, where the compiler is telling me I forgot to pass the required color property to Hey.

Now let's create our real component. Let's create ExpInfo.tsx.

```
import { Component } from "solid-js"

type ExpInfoPropsType = {
}

export const ExpInfo: Component<ExpInfoPropsType> = props => (
  <strong>Placeholder</strong>
);
```

Then change index.tsx to render this new component instead of Hey:

```
import { render } from "solid-js/web";
import { ExpInfo } from "./ExpInfo";

window.addEventListener("load", () => {
  render(() => <ExpInfo />, document.getElementById("root") as Node);
});
```

Now, let's paste in our big blob of prototype HTML.

```
<div class="expinfo_container">
  <div class="expinfo_titlebar">
    <div class="expinfo_timestamp">hh:mm:ss</div>
    <div class="expinfo_timestamp">00:15:00</div>
    <div class="expinfo_timestamp">00:30:00</div>
    <div class="expinfo_timestamp">00:45:00</div>
    <div class="expinfo_timestamp">01:00:00</div>
    <div class="expinfo_timestamp">01:15:00</div>
    <div class="expinfo_timestamp">01:30:00</div>
    <div class="expinfo_timestamp">01:45:00</div>
    <div class="expinfo_timestamp">02:00:00</div>
  </div>
  <div class="expinfo_datatable">
    <div class="expinfo_descr">Temp</div>
    <div class="expinfo_value">60</div>
    <div class="expinfo_value">61</div>
    <div class="expinfo_value">62</div>
    <div class="expinfo_value">63</div>
    <div class="expinfo_value">64</div>
    <div class="expinfo_value">65</div>
    <div class="expinfo_value">66</div>
    <div class="expinfo_value">67</div>
    <div class="expinfo_descr">Stir Speed</div>
    <div class="expinfo_value">300</div>
    <div class="expinfo_value">303</div>
    <div class="expinfo_value">306</div>
    <div class="expinfo_value">309</div>
    <div class="expinfo_value">311</div>
    <div class="expinfo_value">315</div>
    <div class="expinfo_value">312</div>
    <div class="expinfo_value">299</div>
    <div class="expinfo_descr">Amps</div>
    <div class="expinfo_value">3.5</div>
    <div class="expinfo_value">3.6</div>
    <div class="expinfo_value">3.4</div>
    <div class="expinfo_value">3.3</div>
    <div class="expinfo_value">3.3</div>
    <div class="expinfo_value">3.2</div>
    <div class="expinfo_value">3.1</div>
    <div class="expinfo_value">2.9</div>
  </div>
</div>
```

But it doesn't look like much without CSS.

In the public folder, I'll create expinfo.css and paste in the CSS.

```
.expinfo_container {
  width: 800px;
  height: 400px;
  background: black;
  color: white;
}

.expinfo_titlebar {
  display: grid;
  grid-template-columns: 115px repeat(8, 1fr);
  width: 100%;
  background: grey;
}

.expinfo_timestamp {
  font-weight: bold;
  color: #3333CC;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 3px 5px 3px 0px;
}

.expinfo_datatable {
  display: grid;
  grid-template-columns: 115px repeat(8, 1fr);
  width: 100%;
}

.expinfo_descr {
  font-weight: bold;
  color: #55CC55;
  text-align: right;
  border-bottom: 0.1px solid grey;
  padding: 1px 5px 1px 5px;
}

.expinfo_value {
  color: #CCCCCC;
  text-align: right;
  border-bottom: 0.1px solid grey;
  padding: 1px 5px 1px 5px;
}
```

In index.html, I'll create a reference to the css file.

```
    <link href="./experiment-info.css" rel="stylesheet">
```

This project doesn't bundle or hot re-load CSS, so I have to refresh the browser to see these changes.

This is no big trick since the content is static. Of course we want to render the component from data. The magic of a framework like Solid is it figures out how to update the UI efficiently when you change the data behind it. Reactivity is what we want.

To make this work, the data has to be stored in a special state object. Solid provides a function call createState() that creates one of these. Your application can create a single state and store all your data in it, or you can create multiple state objects. This is a design decision that isn't that hard to figure out for your particular app.

You can read and update the state object directly, but I like to wrap it in a helper class to hide some of the implementation details on updates.

In this case I'll create a class to manage the state. I'll call it ExpInfoStore.ts. Does anyone here use classes in their JavaScript code?

Here is a start for the code:

```
import { createState } from "solid-js";

type ExpInfoStateType = {
}

export class ExpInfoStore {
  constructor() {
    let [state, setState] = createState<ExpInfoStateType>({});
  }
}
```

Solid's createState() function returns an array with two elements, what's called a tuple in TypeScript, and we deconstruct those into two variables, state and setState. "state" is an object your component or other code uses to read values in the state. "setState" is a function that must be used when updating the state.

When using TypeScript, the createState() function is given the type of your state object as a generic type argument. I haven't defined any properties for that type yet.

For efficient reactivity, that is updating the DOM efficiently, Solid wraps the state object in a proxy so it knows when and where the state is being read. And the "setState" function makes it obvious to Solid when you are updating it.

In this case, the constructor is creating local variables, but we want to store the returned state in a public class member, and the setState function in a private class member. To tell what type to declare these members as, we rest our cursor on the returned variables.

```
  state: State<ExpInfoStateType>;
  private setState: SetStateFunction<ExpInfoStateType>;
```

Since we want to store these returned values right in the class members, I'll delete the let keyword and reference the instance members.

```
    [this.state, this.setState] = createState<ExpInfoStateType>({});
```

I'll create a method that creates the initial state object.

```
  private createInitialState(): ExpInfoStateType {
    return {
    }
  }
```

Now we have to think about what we put in the state. Since this is TypeScript, we'll first define the type. Let's look at that project that generated the web page from data to get started.

Instead of storing strings for the timestamps, we will store a numeric timestamp for the experiment start time, and then an array of numeric timestamps for each column. This is how timestamps would be stored in a database.

```
type ExpInfoStateType = {
  startTimestamp: number;
  timestamps: number[];
}
```

```
  private createInitialState(): ExpInfoStateType {
    return {
      startTimestamp: 0,
      timestamps: [ -1, -1, -1, -1, -1, -1, -1, -1 ]
    }
  }
```

Timestamps that are -1 will be treated as missing and will be displayed as an empty string.

Now we'll add some throwaway code to the constructor that will dummy up some data. This will also show how the setState() function is used.

```
    // Just use the current time as the starting timestamp.
    let startTimestamp = new Date().getTime();
    this.setState("startTimestamp", startTimestamp);

    // Set timestamps to be at 15 minute intervals.
    for (let i = 0; i < 8; i++) {
      this.setState("timestamps", i, startTimestamp + (i+1) * 15 * 60000);
    }
```

Solid's setState() function has many overloads. Through the magic of TypeScript, when we pass the type of the state object to the createState() function, the setState() function has a lot of type information for our arguments.

It will take an object with properties that will be used to update the underlying state, but I find the overload that takes specific property names as strings to be more commonly used for my purposes. It can even check that the string values that identify the property names are valid.

The first setState() call simply sets the startTimestamp property to the specified value.

The setState() call inside the loop takes an array index as the second argument and the value to set it as the third.

Now when an instance of this class is instantiated, it will be populated with these two properties. So let's change our component to use the values from the state to render the header values.

Since we will later add code to update the state asynchronously, we'll create the store instance outside of the component module. So we'll add this code to the index.tsx file:

```
import { ExpInfoStore } from "./ExpInfoStore";

let store = new ExpInfoStore();
```

Then we'll pass the store to the ExpInfo component, so it can use it.

```
  render(() => <ExpInfo store={store} />, document.getElementById("root") as Node);
```

It'll give us an error until we change ExpInfo to take that property.

```
import { ExpInfoStore } from "./ExpInfoStore";

type ExpInfoPropsType = {
  store: ExpInfoStore;
}
```

Now we'll remove the static timestamps, and generate them from the state data. Solid provides the special For component for looping over data.

```
    <For each={props.store.state.timestamps}>
      {ts => (
        <div class="expinfo_timestamp">{fmtTs(ts)}</div>
      )}
    </For>
```

The For component is passed the "each" property that specifies the collection to iterate over, in this case the timestamps from the state object. The child expression inside the For is a function that's passed each element it is iterating over, and that function returns the JSX to use.

Formatting the timestamp takes a little code, so I'm invoking a function to do that. I'll change it to a multiline function, and declare this little function at the top.

```
  const fmtTs = (ts: number) => ts > 0 ? FormatTime(ts, props.store.state.startTimestamp) : "__:__:__";
```

This function is defined inside the component so it can reference the store property passed in the props argument. The FormatTime function can be implemented outside the component since it is passed everything it needs. I'll put it at the bottom.

```
const FormatTime = (timestamp: number, startTimestamp: number) => {
  // Get number of milliseconds between the timestamp and the start time.
  let time = timestamp > startTimestamp ? timestamp - startTimestamp : 0;
  // Round to nearest second.
  time = Math.round(time / 1000) * 1000;
  // Return formatted string, just hh:mm:ss.
  return new Date(time).toISOString().substring(11, 19);
}
```

Let's change the store to make the timestamps 5 minutes apart instead of 15 to make sure it's working.

Now let's add the rest of the data to the store. We first need to declare the type of this property to store in the state. Looking at the project again that generated the web page from data, here is the new property type:

```
  settings: { descr: string, values: number[] }[];
```

This means the settings property is an array of objects, where each object has a description string and an array of values.

In createInitialState(), we'll initialize that property to an empty array.

```
      settings: []
```

Then we'll update the constructor to put in some dummy data for now.

```
    // Fill in some dummy row data.
    this.setState("settings", 0, "descr", "Temp");
    this.setState("settings", 0, "values", [60, 61, 62, 63, 64, 65, 66, 67]);
    this.setState("settings", 0, "descr", "Stir Speed");
    this.setState("settings", 0, "values", [300, 303, 306, 309, 311, 315, 312, 299]);
    this.setState("settings", 0, "descr", "Amps");
    this.setState("settings", 0, "values", [3.5, 3.6, 3.4, 3.3, 3.3, 3.2, 3.1, 2.9]);
```

Now we'll change our component to render from this data.

```
      <div class="expinfo_datatable">
        <For each={props.store.state.settings}>
          {setting => (
            <>
              <div class="expinfo_descr">{setting.descr}</div>
              <For each={setting.values}>
                {v => (
                  <div class="expinfo_value">{v}</div>
                )}
              </For>
            </>
          )}
        </For>
      </div>
```

The outer For iterates over each setting row, and the inner For iterates over each value for that setting.

Now we're all set up for reactivity. All we need is some code to asynchronously change the data so we can see Solid update the UI automatically.

To simulate returning real data from a database or backend service, I'll create a class called MockDataService that will return dummy data for a specified timestamp.

```
type SettingType = {
  description: string;
  value: number;
}

export class MockDataService {
  private static readonly SettingsMetadata = [
    { descr: "Image Plane (µm)", isInt: true },
    { descr: "Laser %", isInt: true },
    { descr: "Auto Laser 1 on/0 off", isInt: true },
    { descr: "Triage 1 on/0 off", isInt: true },
    { descr: "Min Black Level", isInt: true },
    { descr: "Image Save Interval", isInt: true },
    { descr: "Images/Interval", isInt: true },
    { descr: "Meas Duration (sec)", isInt: true },
    { descr: "Laser Temperature", isInt: false },
    { descr: "Camera Temperature", isInt: false },
    { descr: "Triage Quality %", isInt: true },
    { descr: "Contrast Range", isInt: true },
    { descr: "Image Spacing on/off", isInt: true },
    { descr: "Auto Laser interval", isInt: true },
    { descr: "Exclude Glare on/off", isInt: true },
    { descr: "Glare Level", isInt: true },
    { descr: "Max Glare %", isInt: true }
  ];

  static getSettingsByTimestamp(timestamp: number) {
    return new Promise(function(resolve) {
      // Return data for this timestamp based on modulo 100 of the timestamp.
      let rootVal = Math.floor(timestamp % 100);
      let data: SettingType[] = MockDataService.SettingsMetadata.map((setting, idx) => {
        let val = rootVal + idx;
        return {
          description: setting.descr,
          value: setting.isInt ? val : val + Math.round(Math.random() * 100) / 100
        }
      });
      // Simulate a delay between 0 and 1 seconds before resolving the promise.
      setTimeout(() => resolve(data), Math.floor(Math.random() * 1000));
    });
  }
}
```

I'll remove all the code from the store that populates it with dummy data.

After saving, you see the component is rendered without data.

Now I'll add code to index.tsx to asynchronously populate the state with data over time.

```
```


In my employer's application, the user can manually drag markers around on an adjacent chart to change where the timestamps are. Each marker is assigned a fixed index, 0-7, but what if we want the component to automatically sort by timestamp, so when they reorder the markers, the columns automatically reorder.

