# Introduction

Hello. It's good to see everyone. My name is Eric Schmucker.

I have a lot to cover, so I'll try and move along quickly, but please don't hesitate to stop me to ask questions or give feedback.

Solid is a client side framework where the components managed by Solid are rendered and updated completely in the browser. Having all or part of your web application rendered and managed client side lets your UI be very responsive. It also supports offline web applications that store data in local storage and synchronizes with a backend server when back online.

This approach can **also** be used to create cross-platform apps, with frameworks like Apache Cordova for mobile, and Electron for desktop, leveraging your HTML, CSS and JavaScript knowledge to create an app that runs anywhere.

====Open https://www.blazemetrics.com/====

The company I work for makes microscope-like devices that monitor chemical experiments, and production processes, continually capturing and analyzing images to report what's happening in the reaction chamber. The application is written in C++ for the core logic, with the UI implemented in an embedded Chromium window.

Our UI shows images, charts, and tables of data, all dynamically generated by JavaScript. There's a ton of code, with each visual component requiring thousands of JavaScript lines to build the DOM nodes, change styles, etc. Before Solid, the only 3rd party library used was jQuery.

I haven't loved working on the UI. Examining the code to understand it, even a small part of it, requires pouring through hundreds or even thousands of lines of code.

So when I was tasked with creating a new UI component, I was very eager to find a framework. But it had to be small, efficient and non-intrusive. Something more invasive would have been a hard sell to management and other developers. Solid popped up in my search and I was intrigued by the performance benchmarks.

====Show Solid Web site, search for performance, and click that link, then the 'official results page'====

It's close to the speed of carefully hand-crafted JavaScript. Efficiency, a small payload, and easy integration into an existing web application convinced me to try it.

# Example Page

Using Solid and JSX, I created an example component that's similar to one I created for my job. Here is some static HTML that shows what it will look like:

====Open https://jsfiddle.net/S0Eric/L9b2vdxk/12/ ====

It's a table showing hardware and software settings over the course of an experiment. The columns contain the settings for points in time.

Here is a client-side TypeScript version that creates the same UI dynamically.

====Open https://jsfiddle.net/S0Eric/yvp24mhb/24/ ====

It's the same CSS, but the HTML contains a single placeholder DIV where the component will be rendered, and the TypeScript code generates the UI from data that is just declared at the top. It switches between the two data sets every second by completely re-rendering everything.

Even with a little helper method to create the element nodes, it's hard to tell what the code is doing just by glancing at it. Web developers know HTML, but without a framework and a templating syntax, there is a big gap between the HTML that you prototype, and the resulting code that generates the equivalent UI.

A framework like Solid allows you to write code that generates all or part of your UI with syntax that is not so distant from HTML, and the best part is it makes updating the UI very efficient and straightforward.

# JSX

====Open https://reactjs.org/docs/jsx-in-depth.html====

For the templating syntax, Solid recommends JSX. Solid supports a couple of other templating languages, but JSX looks like the best one.

JSX is a syntax extension to JavaScript, created for the React framework, but it can be used by any framework that supports it. It allows an HTML like syntax to be included in your JavaScript code for describing parts of your UI. It requires a compiler pass to convert the JSX syntax into JavaScript that creates the equivalent DOM nodes.

An example Solid component won't make much sense without some familiarity with JSX. As a matter of fact, JSX is the syntax you use to describe the layout of your UI and Solid is somewhat of a silent actor behind the scenes.

The Babeljs.io web site will let us type in some JavaScript with JSX to see what it compiles to.

====Open https://babeljs.io/ Try it out ====

```

/*************************************/
let x = <div class="title" style="color: green;">Hello!</div>;

/*************************************/
let classname = "title";
function getStyle() {
  return "color: green";
}
let text = "Hello";
let y = <div class={classname} style={getStyle()}>{text + "!"}</div>;

/*************************************/

const OurButton = props => <button style={{color: props.color}}>{props.text}</button>;

const Header = () => (
  <>
    <div class="header-name">Acme Corporation</div>
    <img src="acme.jpg" />
    <div class="header-menu">
      <OurButton text="Home" color="darkgreen" />
      <OurButton text="Products" color="lightgreen" />
      <OurButton text="Contacts" color="lightgreen" />
    </div>
  </>
);
```

JSX looks a lot like HTML, but it isn't really as it gets compiled into JavaScript, and it lets you mix in JavaScript logic and expressions along with the markup syntax.

The JSX compiler simply replaces the JSX syntax in your code with function calls that create the equivalent node structure with nesting of child nodes to any depth. Each resulting JavaScript expression evaluates to a single top level node. So a JSX expression can be used anywhere a JavaScript expression is supported, for example, assigned to a variable, passed as an argument, or returned from a function.

By default, the generated code calls a React's createElement() function to create each node.  To show that JSX isn't just for React, let's add a directive to tell this JSX compiler to use a fictitious function to create the nodes.

```
/** @jsx ourJsxLib.createElem */

```

You could use this feature to invoke your own node creation function to have complete control over how the nodes are created. You could even use JSX for a non-UI related feature that requires generating a tree structure.

The node creation function can create DOM nodes, or virtual DOM nodes, depending on the architecture of the framework. Solid provides its own JSX compiler and support functions to perform some tricks under the covers.

Element attributes, called properties, like class and style, can be specified as string constants, just like in HTML. ====Highlight x expression====

But you can provide values from JavaScript expressions by surrounding them in curly braces. ====Highlight the y expression==== This JSX expression gets its class from a string variable, its style from calling a function, and the child text from a JavaScript string expression. You can see from the generated code how natural that ends up working since it's all JavaScript in the end.

The most common way to use JSX is to define a function that returns a JSX expression. Such a function becomes a re-usable component, as shown by the Header component that contains three OurButton components. The passed properties, like OurButton's text and color, are combined into a single object that is passed to the component as a single **props** argument. See how the OurButton component accesses those passed properties from that **props** object.

Another thing to note is styles can be specified as a string, or as an object with each property of that object specifying a different style. Here it requires double curly braces - the outer ones to indicate this is a JavaScript expression, and the inner ones to indicate this is an object literal.

The Header component is a single-line arrow function, so it doesn't have curly braces, but it's recommended that JSX spread over multiple lines is enclosed in parenthesis.

Finally, JSX has to resolve to a single node, but the Header component contains a list of elements without a natural top-level node to contain them. When this happens, you have to enclose your element list with this blank tag, which is a non-node container called a fragment. When a fragment is provided for insertion as a child of another node, it inserts the children, not the fragment.

The OurButton and Header components declared here are implemented as arrow functions. I use them almost exclusivly. I'll post a link to an interesting article about arrow functions. As this article says, arrow functions provide "a very clean concise syntax and more intuitive scoping and this binding".

Is anyone unfamiliar with arrow function syntax?

```
/*************************************/

// Most traditional named JavaScript function.
function add1(a, b) {
    return a + b;
}

// Anonymous function assigned to add2.
const add2 = function(a, b) {
  return a + b;
}

// Multi-line arrow function.
const add3 = (a, b) => {
  return a + b;
}

// Single-line arrow function. Body expression is the return value.
const add4 = (a, b) => a + b;

// Very handy when passing a small anonymous function.
let a = [ {name: "Mary", age: 25}, {name: "Nanook", age: 52}, {name: "Fred", age: 22} ];
// Sort object array by age property.
a.sort((a,b) => a.age - b.age);
console.log(a);
```

Arrow function syntax is perfect when you want to pass a small anonymous function as an argument. It also fixes issues with "this" binding, making it more intuitive for people who come from other OO languages, so I use it exclusively. Except, I read it shouldn't be used for class methods.

====####====

You'll see how JSX is used in the component I'm about to create, but does anyone have any questions about this so far?

# UI = F(S)

====Show Blaze web site====

One of the difficulties when writing user interfaces is determining when and what parts of the UI need updating as the user interacts with it and data comes in from the backend. If we look at my employer's application, there is a lot of data behind this UI with a lot of it being displayed in multiple places. For example, you can drag one of those color markers around the bottom of the chart's timeline, and that changes data in the chart on the right. The list of events on a timeline under the chart are also in a small scrollable list in the middle right. When a data point changes, such as a marker moves, or an event gets added, updated, or deleted, you have to update your in-memory list, and if you are brave, you write code to incrementally update the UI to match the data change you just made. The easiest thing to do is call a function that re-renders any component that might show that changed data. That isn't efficient and it gets more complicated as your UI gets bigger. Let's say that you have a feature where a button becomes visible when an event of a specific type exists. You have to put extra logic somewhere that runs whenever that list changes, and checks if the button should be enabled or disabled. UI logic get's spread all over the place.

When you have a framework that solves this problem for you, you only have to write code to manage your application data, or what is called the state of your application, like updating it when data comes in from the backend or the user clicks something, and you have to write code that generates the UI from that state. The framework takes care of the rest.

This may seem theoretical, but these equations explain it well:

====Show UI equations slide 3====

Basically, you have to write function R that takes an event and the current application state and creates the new application state. And you have to write function F, which is actuall a composition of functions that generates your UI from the current state.

For web applications, since updating the DOM is considered expensive, doing this in an efficient way is the trick.

As you saw, JSX let's you write functions that generate your UI, so it's a perfect analogy to the F function. You could implement a formal R function. React's Redux framework does something like that. But what I do is a little simpler. I create a class that manages the application state and provides high level methods for updating the state. It's a looser analogy to the R function, but close.

For me, after working on a codebase for a while that updates the UI explcitly, discovering a framework that eliminates all that hassle allowed me to love doing UI work. If you live there already, then good for you.

All right, now on to the sample component.

# Node Project

Compiling a Solid project is a little involved, but in the end, all your code gets compiled and bundled with the small Solid runtime into one JavaScript file.

Solid's "getting started" guide provides a simple node template project to get started, but its configuration is somewhat hidden, so I created a more explicitly configured node project. I'll post a link to a small GitHub project based on that to the Meetup group.

The build process uses Webpack to perform module resolution, dead code elimination, and minification. Solid provides its own JSX compiler implemented as a babel plugin, and I like to use TypeScript, so that's in the mix also.

Here is the example component project I mentioned earlier, opened in Visual Studio Code. I commented out almost all the code and will uncomment it one piece at a time so you can see how you would go from nothing to a complete project step by step.

You have to download all dependencies with the NPM INSTALL command.

```
npm install
```

Looking at the project folder structure, the **dist** folder contains everything you would deploy to a web server. The **src** folder contains all the source files. Source files can be any combination of JavaScript or TypeScript files, with or without JSX.

See that the index.html file contains a single DIV element where our new component will be rendered. The only source code required at this point is the index.tsx file that defines and renders a simple component.

To start the Webpack development web server, which will build the app, serve it up, and support hot-reload, type this command in the terminal window. This is a shortcut to run the longer command associated with "dev" in the scripts section of the package.json file:

```
npm run start
```

Now we can open the web app by control-clicking the link shown in the terminal window.

You can write all this in JavaScript if you want, but I'm partial to TypeScript. If you aren't interested in TypeScript, you can mentally remove all standalone type definitions and type annotations, and that would be your equivalent JavaScript. Instead of ts and tsx file types, you would create js and jsx files.

The entry point of the application is the index.tsx file. Try to ignore the commented out code. Ignore the little man behind the curtain.

When the window loads, it invokes Solid's render() funtion, which takes two arguments, the first being a function that returns the JSX expression to render, and the second is the element to render it under. In this case, it'll render the Hey component under the element with the id of "root".

Webpack's development server supports hot-reload, so if I change something and save, it'll recompile and reload automatically.

The Hey component is a simple component, but with TypeScript's strict mode turned on, everything is required to have a type declared or inferred. The props argument is declared as an object that has a "text" property that is a string.

This works in this simple case, but with Solid, you should use the built-in Component type, giving the type of your props object as a generic type passed to Component.

You can imagine if your component takes many arguments, this type can get long, so I like to declare a named type for the props parameter right before the component.

I added a color property to the Hey component. Doing the extra work of adding types provides benefits like this, where the compiler is telling me I forgot to pass the required color property to Hey.

Now let's create our real component. The ExpInfo.tsx file contains a start. At this point, it contains static JSX that shows prototype of the table.

Let's change index.tsx to render that instead of Hey.

But of course, we want our UI to render reactively from data. So it's time to think about our application state. The ExpInfoStore.ts defines our class that will manage our application state.

To be reactive, Solid requires that you use its createState() function to create the state object. Your application can create a single state and store all your data in it, or you can create multiple state objects. That's a design decision that isn't that hard to figure out for your particular app, or change as your design develops.

createState() takes an initial state object as a parameter and returns an array with two elements, what is called a tuple in TypeScript and other languages. This destructuring syntax breaks out those two array elements into separate variables.

**state** is an object your component and other code uses to read values from the state. **setState** is a function that must be used to update the state.

When using TypeScript, the createState() function is given the type of your state object as a generic type argument. I haven't defined any properties for that type yet.

For efficient reactivity, that is, updating the DOM efficiently, Solid wraps the passed initial object in a proxy and returns that, so it knows when and where the state is being read. And the **setState** function makes it obvious to Solid when you are updating it.

I want to store the returned state in a public class member, and the setState function in a private class member. The **setState** function is stored private because we will expose public helper methods for updating state instead of having external components use setState directly. To tell what type to declare these members as, we can rest our cursor on the returned variables.

====Uncomment state, setState and the call to createState()====

By the way, when I save these changes, the app isn't recompiling because Webpack eliminated it because it isn't being referenced anywhere yet.

Now we have to think about what we put in the state. Since this is TypeScript, we'll first define the type. To get a clue, let's look at that project that generated the web page from data. We need a list of timestamps, and a list of object containing a description and a list of values.

====Uncomment the state's types====

Instead of storing strings for the timestamps, we will store a numeric timestamp for the experiment start time, and then an array of numeric timestamps for each column. This is how timestamps would be stored in a database. The displayed time strings will be the offset of each timestamp from the start of the experiment, calculated inside the component function.

The reason the timestamps and values array elements have a type of number **or** undefined is we want to be able to clear a column of data by setting the values in that column to undefined, and the component will display these missing values with special markers. I found that Solid doesn't perform as well with sparse arrays, so I'm filling them in initially with undefined values.

Now we know what to pass inside our initial state object.

====Uncomment the initial object====

Let's quickly look at the mock data service module. This module exports a class with a single static getSettingsByTimestamp() method that returns a promise that within a random amount of time from 0 to 1 second, it will return random data for a list of hardcoded settings. We'll use this to simulate pulling data from a backend database.

Let's go back to our index.tsx file and invoke it to see what it returns.

====Uncomment the call to getSettingsByTimestamp====

It logs the returned structure to the console, so let's look at that in the browser debugger tools. This function will be called to simulate fetching data for a column in our table.

Ok, back to our store class. 

As far as updates go, external code will simulate the user clicking buttons or dragging icons that change what timestamps they want to see. When a timestamp for any particular index changes, a method will be called on our store instance, indicating that the timestamp for column index X has changed. The store will clear the values for that column. Then the data service will be invoked to obtain settings values that timestamp. When that promise resolves, it'll call another method on the store instance to populate that column's values with the returned data.

Oh, and there is a method to set the start timestamp of the experiment.

I'll uncomment these three methods.

My real data service could return a different list of settings for different timestamps, and in a different order. So as rows in the table are created, I need to record which setting description has been assigned to which row. This is tracked in this descrToRowIndex object. This TypeScript type syntax says that any number of properties can be stored in this object, and the value types are all numbers. This object maps a setting descrption to a previously assigned row index.

These three state update methods illustrate a number of powerful overloads that Solid's **setState** function provides. You can pass an object to it containing the properties you want to update, but I generally found the overloads that take a propery name as a string more convenient when I'm setting a specific value deep in the structure.

setStartTimestamp() uses a simple overload that specifies the property name to update and the value to assign.

setTimestamp() uses a overload of **setState** for updating an array where the index to update is specified after the property name. When updating the **values** array that is inside the settings array, you can see this overload takes the indexes after each property name.

This really blew my mind when I first saw it. I didn't know TypeScript supported such powerful type definitions. Just by passing the state type definition as a generic type parameter to createState(), the returned **setState** function has type information transferred to it that invalid calls to it are flagged by the compiler. Watch what happens when I use an invalid property name, or put in an extra argument, or take one out.

I looked at Solid's source code for the setState() function and it used the most complex TypeScript type definitions I've ever see. I wasn't able to follow it, but luckily, I don't have a need to create a powerful API like this.

setSettings() is a little more complex because it may optionally add rows to the state's settings property if a row for a particular description doesn't exist already.

Since we want the state to be updated outside of our ExpInfo component, we'll create it outside of the component and pass it in.

====Uncomment out store creation in index.tsx, startTimestamp setting, and pass the store to ExpInfo====

Since ExpInfo is going to render its data from the state, we will pass the store to it. But we haven't modified ExpInfo to take that property, so let's do that.

Now we need to populates the state with data.

====Uncomment populateState() in index.tsx, and the call to it====

So, two seconds after rendering the blank component, it will populate all timestamps with timestamps 5 minutes apart.

Now that we have some data in the state object, we have to change our component to render its UI from that data.

Let's delete the 8 static timestamp DIVs, and uncomment the code that creates them from the timestamps array. Solid provides special For and Index loop components that iterate over a collection, specified by the each property. The For component is for looping through a list of objects, while the Index component is for looping through a list of primitives. To minimize re-rendering, Solid has to know when an item in a list has changed. Each object has a unique ID, but primitives don't. The Index component uses the list index as the key.

For each element in the collection, For and Index invoke the function that is a child of the loop component. That function returns the JSX that will be used.

Formatting the timestamp required a bit of code, so I'll uncomment the fmtTs function that does that. It displays a special string if the timestamp is undefined, or if the timestamp is a number then it subtracts it from the experiment start timestamp to get the offset time and formats that as a string.

When I save this file, it'll hot reload and you'll see the blank timestamp placeholders and then the actual timestamps 2 seconds later. Now let's tackle the values.

Rendering the settings rows is very similar except it performs two nested loops.

====Delete all the static data and uncomment out the dynamic part====

The outer For iterates over each setting row, the outer loop function creates the DIV containing the description and then iterates over each value in that setting row.

The inner Index function invokes the fmtValue function that displays the value as a string, or a dash if it's undefined.

====Uncomment the fmtValue function====

Now when I save the code, we see the table is dynamically populated from state data.

To make it a little more interesting, let's add buttons to the component that let the user adjust the gap between the timestamps. But we want the component to invoke a callback function passed to it from index.tsx when the buttons are pressed.

Since this is a new property passed to ExpInfo, we'll add that to the props argument type definition.

```
  updownCb?: (isDown: boolean) => void;
```

The question mark is shortcut TypeScript syntax to say it can be undefined, making it an optional property. But you have to check for that in your code.

```
      <Show when={props.updownCb !== undefined}>
        <button style="width:100px" onClick={() => handleUpDownClick(true)}>Down</button>
        <button style="width:100px" onClick={() => handleUpDownClick(false)}>Up</button>
      </Show>
```

Since we no longer have a single top level node, I have to enclose the returned element list in a fragment.

That Show component is provided by Solid to optionally render its child components if the expression in the when property is true. So if the callback function isn't passed, it won't render the buttons.

The buttons call a local function to handle the click, which simply invokes the passed callback if it was specified.

```
  // Handle the up/down button clicks.
  const handleUpDownClick = (isDown: boolean) => {
    if (props.updownCb !== undefined)
      props.updownCb(isDown);
  }
```

When I save this, the app recompiles, but because we aren't passing in a callback, the buttons aren't rendered.

In index.tsx, I'll define the function that will be passed to ExpInfo.

```
let currentGapMinutes = 15;

const adjustTimestampGap = (isDown: boolean) => {
  if (isDown) {
    if (currentGapMinutes > 5) {
        currentGapMinutes -= 5;
        populateState(currentGapMinutes)
      }
    }
  else {
    if (currentGapMinutes < 60) {
      currentGapMinutes += 5;
      populateState(currentGapMinutes)
    }
  }
}
```

It'll adjust the current timestamp gap up or down, but limits the range to 5 to 60 minutes.

And we want it to initially render at the current setting.

```
  setTimeout(() => populateState(currentGapMinutes), 2000);
```

Now we'll pass the function to the ExpInfo component.

====Type it in====

Now when the code is saved, the buttons are rendered and they work.

I like that we didn't have to write any code to update the UI, and I like JSX because I was able to start with the HTML from my prototype and the resulting code has a vague resemblance to the original HTML. And in the end there is very little code here.

Is everyone still awake?

There is still the big question of how Solid efficiently updates the UI.

Let's put in some console logging to see how often it calls various functions.






https://codeburst.io/jsx-and-html-templates-893ca24c1987

https://www.youtube.com/playlist?list=PLtLhzwNMDs1fMi43erQSzXD49Y4p0TniU

https://zendev.com/2018/10/01/javascript-arrow-functions-how-why-when.html
